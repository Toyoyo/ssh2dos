<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Watt-32 tcp/ip: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Watt-32 tcp/ip
   &#160;<span id="projectnumber">2.2 dev-rel.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('todo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000049"></a>Global <a class="el" href="pcarp_8h.html#a03d045377faa806fac5adf421239c348">_arp_add_gateway</a>  (const char *config_string, DWORD ip)</dt>
<dd>Move to route.c and rename to route_add().  </dd>
<dt><a class="anchor" id="_todo000052"></a>Global <a class="el" href="pcarp_8h.html#ae40c8004b6905324e6b98d692db726ba">_arp_gateways_get</a>  (const struct <a class="el" href="structgate__entry.html">gate_entry</a> **)</dt>
<dd>: Move to route.c and prefix with '_route'. </dd>
<dt><a class="anchor" id="_todo000052"></a>Global <a class="el" href="pcarp_8h.html#ae40c8004b6905324e6b98d692db726ba">_arp_gateways_get</a>  (const struct <a class="el" href="structgate__entry.html">gate_entry</a> **)</dt>
<dd>: Move to route.c and prefix with '_route'. </dd>
<dt><a class="anchor" id="_todo000163"></a>Global <a class="el" href="x32vm_8h.html#a743f9183b641007219e43b7f410888e1">_dx_real_alloc</a>  (int paras, WORD *para, WORD *largest)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000163"></a>Global <a class="el" href="x32vm_8h.html#a743f9183b641007219e43b7f410888e1">_dx_real_alloc</a>  (int paras, WORD *para, WORD *largest)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000083"></a>Global <a class="el" href="pcsed_8c.html#ae158a0791f36d20f60aa9db52f48b147">_eth_arrived</a>  (WORD *type_ptr, BOOL *broadcast)</dt>
<dd>push back packet, else it's lost  </dd>
<dt><a class="anchor" id="_todo000083"></a>Global <a class="el" href="pcsed_8c.html#ae158a0791f36d20f60aa9db52f48b147">_eth_arrived</a>  (WORD *type_ptr, BOOL *broadcast)</dt>
<dd>push back packet, else it's lost  </dd>
<dt><a class="anchor" id="_todo000034"></a>Global <a class="el" href="ip4__in_8h.html#a6a67b6f026771f6f5c16853b0ccf052b">_ip4_handler</a>  (const <a class="el" href="structin___header.html">in_Header</a> *ip, BOOL broadcast)</dt>
<dd><p class="startdd">check for LSRR option and replace ip-&gt;source with actual source-address burried in option (ref. RFC-1122) </p>
<p class="enddd">handle compressed IP (use zlib)  </p>
</dd>
<dt><a class="anchor" id="_todo000036"></a>Global <a class="el" href="ip4__out_8h.html#a41e8212a74160eb06ba73ce91b316ed6">_ip4_output</a>  (<a class="el" href="structin___header.html">in_Header</a> *ip, DWORD src_ip, DWORD dst_ip, BYTE protocol, BYTE ttl, BYTE tos, WORD ip_id, int data_len, const void *sock, const char *file, unsigned line)</dt>
<dd>Handle IP-fragments here (call ip4_send_fragments() when needed)  </dd>
<dt><a class="anchor" id="_todo000037"></a>Global <a class="el" href="ip4__out_8h.html#aac0325bb856ce9d79ed6949a09a824fb">_ip4_send_fragments</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *sk, BYTE proto, DWORD dest, const void *buf, unsigned len, const char *file, unsigned line)</dt>
<dd>Maybe send highest offset fragment first?  </dd>
<dt><a class="anchor" id="_todo000037"></a>Global <a class="el" href="ip4__out_8h.html#aac0325bb856ce9d79ed6949a09a824fb">_ip4_send_fragments</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *sk, BYTE proto, DWORD dest, const void *buf, unsigned len, const char *file, unsigned line)</dt>
<dd>Maybe send highest offset fragment first?  </dd>
<dt><a class="anchor" id="_todo000038"></a>Global <a class="el" href="ip6__out_8h.html#a2b96bc0934a3bd80e1b5167d39b5a6d4">_ip6_output</a>  (<a class="el" href="structin6___header.html">in6_Header</a> *ip, ip6_address *src_ip, ip6_address *dst_ip, BYTE next_hdr, unsigned data_len, int hop_lim, const void *sock, const char *file, unsigned line)</dt>
<dd>: Support fragments  </dd>
<dt><a class="anchor" id="_todo000038"></a>Global <a class="el" href="ip6__out_8h.html#a2b96bc0934a3bd80e1b5167d39b5a6d4">_ip6_output</a>  (<a class="el" href="structin6___header.html">in6_Header</a> *ip, ip6_address *src_ip, ip6_address *dst_ip, BYTE next_hdr, unsigned data_len, int hop_lim, const void *sock, const char *file, unsigned line)</dt>
<dd>: Support fragments  </dd>
<dt><a class="anchor" id="_todo000002"></a>Global <a class="el" href="src_2socket_8h.html#a5d3c54951e07e36b13aa7c1127c9a3d0">_sock_append</a>  (_tcp_Socket **tcp)</dt>
<dd><p class="startdd">Implement SYN-cookies. Ref. <a href="http://cr.yp.to/syncookies.html">http://cr.yp.to/syncookies.html</a> </p>
<p>Implement SYN-cookies and drop the segment if no match </p>
<p class="enddd">drop the oldest (or a random) slot in the listen-queue.  </p>
</dd>
<dt><a class="anchor" id="_todo000118"></a>Global <a class="el" href="src_2socket_8h.html#a2589625af0621f9d649f496df203093c">_sock_set_rcv_buf</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s, size_t len)</dt>
<dd>allow user to define size using SO_RCVBUF/SO_SNDBUF before calling connect().  </dd>
<dt><a class="anchor" id="_todo000126"></a>Global <a class="el" href="src_2socket_8h.html#ae3d4685a125fb6e981e07506f2651288">_TCP6_listen</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *host, WORD loc_port)</dt>
<dd>Support TCP listen() for AF_INET6  </dd>
<dt><a class="anchor" id="_todo000123"></a>Global <a class="el" href="src_2socket_8h.html#a14b79cb455cca37f583e3e15ff9740fe">_TCP6_open</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *host, WORD loc_port, WORD rem_port)</dt>
<dd><p class="startdd">use mss from setsockopt() </p>
<p>Yield for IPv6 sockets </p>
<p class="enddd">use TCP_NODELAY set in setsockopt()  </p>
</dd>
<dt><a class="anchor" id="_todo000123"></a>Global <a class="el" href="src_2socket_8h.html#a14b79cb455cca37f583e3e15ff9740fe">_TCP6_open</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *host, WORD loc_port, WORD rem_port)</dt>
<dd><p class="startdd">use mss from setsockopt() </p>
<p>Yield for IPv6 sockets </p>
<p class="enddd">use TCP_NODELAY set in setsockopt()  </p>
</dd>
<dt><a class="anchor" id="_todo000128"></a>Global <a class="el" href="src_2socket_8h.html#aa37cab9b7907b01483bd64649df88bc3">_UDP6_listen</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *host, WORD port)</dt>
<dd>Support UDP listen() for AF_INET6  </dd>
<dt><a class="anchor" id="_todo000127"></a>Global <a class="el" href="src_2socket_8h.html#a144cbd6d9913d1f5d1ecc4f898ade660">_UDP6_open</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *host, WORD loc_port, WORD rem_port)</dt>
<dd>Support UDP connect() for AF_INET6  </dd>
<dt><a class="anchor" id="_todo000018"></a>Global <a class="el" href="getopt_8c.html#a8524dd9262661ca49962f9a72223a924">_w_watt_optarg</a>  </dt>
<dd>make a wide-char version of getopt()  </dd>
<dt><a class="anchor" id="_todo000001"></a>Global <a class="el" href="accept_8c.html#a6aa3b68cb25a99a7dbcf7264f3772bd0">accept</a>  (int s, struct sockaddr *addr, socklen_t *addrlen)</dt>
<dd>Should maybe loop over all maxconn TCBs and accept the one with oldest 'syn_timestamp'.  </dd>
<dt><a class="anchor" id="_todo000005"></a>Global <a class="el" href="inc_2sys_2socket_8h.html#acbce629fe663e05a215d91be7ef22c51">bind</a>  (int, const struct sockaddr *, socklen_t)</dt>
<dd>check for "sleeping" ports (lport_inuse in <a class="el" href="pctcp_8c.html">pctcp.c</a>) also. And return EADDRINUSE if local port not free.  </dd>
<dt><a class="anchor" id="_todo000005"></a>Global <a class="el" href="inc_2sys_2socket_8h.html#acbce629fe663e05a215d91be7ef22c51">bind</a>  (int, const struct sockaddr *, socklen_t)</dt>
<dd>check for "sleeping" ports (lport_inuse in <a class="el" href="pctcp_8c.html">pctcp.c</a>) also. And return EADDRINUSE if local port not free.  </dd>
<dt><a class="anchor" id="_todo000045"></a>Global <a class="el" href="misc_8c.html#af14f8e3934471a519ce23960db7a6250">crtdbg_exit</a>  (void)</dt>
<dd>: show a better MessageBox(). Show backtrace from where abort() was called; skip the 2 first CRT locations (raise, abort). Indent the printout 2 spaces.  </dd>
<dt><a class="anchor" id="_todo000055"></a>Global <a class="el" href="pcdbug_8h.html#ab0107c02f3a3dc31a6b1dd520412ece7">dbg_mode_all</a>  </dt>
<dd>make them static.  </dd>
<dt><a class="anchor" id="_todo000064"></a>Global <a class="el" href="pcdhcp_8c.html#a815fcae436afd77800e5ffbc38b894ae">DHCP_offer</a>  (const struct dhcp *in)</dt>
<dd>make a hook for SMB-lib  </dd>
<dt><a class="anchor" id="_todo000066"></a>Class <a class="el" href="struct_d_n_s___header.html">DNS_Header</a>  </dt>
<dd>Rewrite to use only 'struct <a class="el" href="struct_d_n_s___header.html" title="Another definition of &#39;struct DNS_head&#39;. ">DNS_Header</a>'.  </dd>
<dt><a class="anchor" id="_todo000058"></a>Global <a class="el" href="pcdbug_8c.html#a9260f3a1434719cf580c71ef77cb167f">dns_opcodes</a>  [16]</dt>
<dd>parse the SRV resource record (RFC 2052)  </dd>
<dt><a class="anchor" id="_todo000008"></a>Global <a class="el" href="echo_8c.html#a34497d03779a31712a52a90f2442cc6c">echo_discard_daemon</a>  (void)</dt>
<dd>handle jumbo packets (IP-fragments)  </dd>
<dt><a class="anchor" id="_todo000021"></a>Global <a class="el" href="ioctl_8c.html#aca1829882cf43c2f83c2596a91d5461d">eth_ifnet</a>  (void)</dt>
<dd>fill info  </dd>
<dt><a class="anchor" id="_todo000150"></a>Global <a class="el" href="wdpmi_8c.html#a3026c6d145379cc8eb371a96e85cbe2a">exc_app_start</a>  </dt>
<dd>find the real application start  </dd>
<dt><a class="anchor" id="_todo000107"></a>Global <a class="el" href="select_8c.html#afbb8d022768afa6a660e18aec1d3cac6">exc_select</a>  (int s, <a class="el" href="struct_socket.html">Socket</a> *socket)</dt>
<dd>Only arrival of OOB-data should count here  </dd>
<dt><a class="anchor" id="_todo000110"></a>Global <a class="el" href="sock__ini_8c.html#afec75dd70efe566b18f71bc1274fb4df">except_handler</a>  (int sig)</dt>
<dd>Disassemble crash address. Don't confuse this yet-to-be function with the function ShowStack() in stkwalk.cpp. That one is for Win32 only.  </dd>
<dt><a class="anchor" id="_todo000053"></a>Global <a class="el" href="pcconfig_8h.html#a1fef0683080ae3d4dd8cdbc32756c597">expand_var_str</a>  (const char *str)</dt>
<dd>support several  in one line and malloc the result.  </dd>
<dt><a class="anchor" id="_todo000010"></a>Global <a class="el" href="inc_2sys_2socket_8h.html#aac3df9d5fd8569c3122acd4deb4d8c81">fcntlsocket</a>  (int s, int cmd,...)</dt>
<dd>handle <b>O_TEXT</b> and <b>O_BINARY</b>  </dd>
<dt><a class="anchor" id="_todo000082"></a>Global <a class="el" href="pcsed_8c.html#aa991e4288fdba0dca6be4ae3ac445912">fix_llc_head</a>  (void **mac)</dt>
<dd>handle IEEE 802.3 encapsulation also.  </dd>
<dt><a class="anchor" id="_todo000050"></a>Class <a class="el" href="structgate__entry.html">gate_entry</a>  </dt>
<dd>Move the gateway/route stuff to route.c  </dd>
<dt><a class="anchor" id="_todo000158"></a>Global <a class="el" href="winpkt_8c.html#a76bd8cb846b37b38094b43225605becc">get_if_type_airpcap</a>  (const AIR_ADAPTER *adapter, WORD *type)</dt>
<dd>Fix me  </dd>
<dt><a class="anchor" id="_todo000157"></a>Global <a class="el" href="winpkt_8c.html#a64765bfe8e61e6b58157f7dbad3b124a">get_if_type_swsvpkt</a>  (const struct <a class="el" href="struct_sws_vpkt_usr.html">SwsVpktUsr</a> *usr, WORD *type)</dt>
<dd>Fix me  </dd>
<dt><a class="anchor" id="_todo000129"></a>Global <a class="el" href="sockopt_8c.html#ab64ee68e5901f41b5da61733ccb36f66">get_sol_opt</a>  (<a class="el" href="struct_socket.html">Socket</a> *s, int opt, void *val, int *len)</dt>
<dd><p class="startdd">Handle urgent (OOB) data </p>
<p class="enddd">Handle these SOL_OPTIONS:  </p>
</dd>
<dt><a class="anchor" id="_todo000016"></a>Global <a class="el" href="gethost6_8c.html#aab421af6d959dde4bd509784c908bea5">gethostbyaddr6_internal</a>  (const char *addr, struct <a class="el" href="struct__hostent6.html">_hostent6</a> *ret)</dt>
<dd><p class="startdd">should check all addresses </p>
<p class="enddd">should be the new aliases  </p>
</dd>
<dt><a class="anchor" id="_todo000014"></a>Global <a class="el" href="gethost_8c.html#abd1af4101b6b4d58c1570ab161cac92a">gethostbyaddr_internal</a>  (const char *addr_name, int len, int type, struct <a class="el" href="struct__hostent.html">_hostent</a> *ret)</dt>
<dd><p class="startdd">Should return all our addresses if we're multihomed. </p>
<p class="enddd">should be the new aliases  </p>
</dd>
<dt><a class="anchor" id="_todo000013"></a>Global <a class="el" href="gethost_8c.html#ae9ec724dba46f13a9c0f2cfd5c358385">gethostbyname_internal</a>  (const char *name, const char **alias, struct <a class="el" href="struct__hostent.html">_hostent</a> *ret)</dt>
<dd>should be canonical name  </dd>
<dt><a class="anchor" id="_todo000057"></a>Global <a class="el" href="pcdbug_8c.html#a3a084a9cc86486fe364d70a229215eea">icmp4_dump</a>  (const <a class="el" href="structin___header.html">in_Header</a> *ip)</dt>
<dd>Handle debugging of these  </dd>
<dt><a class="anchor" id="_todo000074"></a>Global <a class="el" href="pcicmp6_8h.html#abb6d295f76164e0cb01d6692cfc34c0b">icmp6_neigh_solic</a>  (const void *addr, eth_address *eth)</dt>
<dd>wait for Neighbor Advertisement  </dd>
<dt><a class="anchor" id="_todo000067"></a>Global <a class="el" href="pcicmp_8h.html#a83f211ebe1d063bb2a7dcfc7bf03c07a">icmp_handler</a>  (const <a class="el" href="structin___header.html">in_Header</a> *ip, BOOL broadcast)</dt>
<dd><p class="startdd">Handle cancelling raw sockets </p>
<p>!! </p>
<p>!! </p>
<p>send reply? </p>
<p>should store </p>
<p>send reply </p>
<p class="enddd">send reply upwards  </p>
</dd>
<dt><a class="anchor" id="_todo000039"></a>Global <a class="el" href="loopback_8c.html#a9d656e136b8e40b8d14473f47cbb8435">icmp_loopback</a>  (<a class="el" href="union_i_c_m_p___p_k_t.html">ICMP_PKT</a> *icmp, unsigned icmp_len)</dt>
<dd>fall-through to another ICMP loopback handler  </dd>
<dt><a class="anchor" id="_todo000020"></a>Global <a class="el" href="idna_8h.html#a2fcc0a091f8b8fffea710151e21f0480">IDNA_convert_from_ACE</a>  (char *name, size_t *size)</dt>
<dd>Check for over-run on output. </dd>
<dt><a class="anchor" id="_todo000023"></a>Global <a class="el" href="ioctl_8c.html#a651364ebc21534830faf133d3d74e3c0">iface_ioctrl</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, long cmd, char *argp)</dt>
<dd><p class="startdd">Get point-to-point address </p>
<p>Set point-to-point address </p>
<p>Set interface metric </p>
<p>Handle deleting interface address </p>
<p class="enddd">Handle add/change interface alias  </p>
</dd>
<dt><a class="anchor" id="_todo000033"></a>Global <a class="el" href="ip4__frag_8c.html#a7157fd038490ae85b2a136077259a1ab">init_frag</a>  (int argc, char **argv)</dt>
<dd>Simulate fragment timeout  </dd>
<dt><a class="anchor" id="_todo000098"></a>Global <a class="el" href="ports_8c.html#a356f500b6f0d35986bdbb00b7bbcc227">init_localport</a>  (void)</dt>
<dd><p class="startdd">Make empherical port range configurable. </p>
<p class="enddd">Use some hashing technique to speed up find_free_port().  </p>
</dd>
<dt><a class="anchor" id="_todo000044"></a>Global <a class="el" href="misc_8c.html#a60209476028cda72ee97714aac1c7044">init_misc</a>  (void)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000142"></a>Global <a class="el" href="timer_8h.html#aa0a564ad303951ed6ec0b1fb5d91d2a7">init_timers</a>  (void)</dt>
<dd>check if 8254 PIT is really working  </dd>
<dt><a class="anchor" id="_todo000144"></a>Global <a class="el" href="transmit_8c.html#ac90d61f3957059dcf29cbdb3ca383437">ip4_transmit</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *tx, unsigned len)</dt>
<dd>Handle sending fragments with IP optons  </dd>
<dt><a class="anchor" id="_todo000145"></a>Global <a class="el" href="transmit_8c.html#a0ddba1e50bd2b3c9a89347d95f7bcc30">ip6_transmit</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *tx, unsigned len)</dt>
<dd>support fragmentation  </dd>
<dt><a class="anchor" id="_todo000042"></a>Global <a class="el" href="misc_8c.html#a5c37009417abbd07931e31ddf8d9b788">is_in_stack_init</a>  (void)</dt>
<dd><p class="startdd">Make CS writable </p>
<p class="enddd">Make CS read-only  </p>
</dd>
<dt><a class="anchor" id="_todo000019"></a>Global <a class="el" href="highc_8c.html#a8c9f1307baa30cc65e521a9512b64602">is_watt32_func</a>  (const char *func)</dt>
<dd>Fill in the rest (use a generated table?)  </dd>
<dt><a class="anchor" id="_todo000009"></a>Global <a class="el" href="echo_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>  (int argc, char **argv)</dt>
<dd>Make a <b>echo</b> client/server test program  </dd>
<dt><a class="anchor" id="_todo000056"></a>Global <a class="el" href="pcdbug_8c.html#af41b45fc803fa6a9488babdd625a7424">match_ip6_dest</a>  (const <a class="el" href="structin6___header.html">in6_Header</a> *ip)</dt>
<dd>needs work  </dd>
<dt><a class="anchor" id="_todo000089"></a>Global <a class="el" href="pctcp_8h.html#a44ed0e41d4d4b80b96255af52da96eb3">mtu_blackhole</a>  </dt>
<dd>Add PMTU blackhole detection  </dd>
<dt><a class="anchor" id="_todo000088"></a>Global <a class="el" href="pctcp_8h.html#a78f8b2951229ede7122c65f90263700c">mtu_discover</a>  </dt>
<dd>Add PMTU discovery method  </dd>
<dt><a class="anchor" id="_todo000153"></a>Global <a class="el" href="winmisc_8c.html#aa0a935502d8f0b6c763f747c1f142963">new_abort_handler</a>  (int sig)</dt>
<dd>: show a better MessageBox(). Show backtrace from where abort() was called; skip the 2 first CRT locations (raise, abort). Indent the printout 2 spaces.  </dd>
<dt><a class="anchor" id="_todo000006"></a>Global <a class="el" href="bsddbug_8c.html#a1d4b111d59715845c64de3341bafaffb">ods_printf</a>  (const char *fmt, va_list arg)</dt>
<dd>: Needs to be rewritten to handle line-buffering. </dd>
<dt><a class="anchor" id="_todo000159"></a>Global <a class="el" href="winpkt_8c.html#a42b5232b3a472bb41f133d4c87245548">open_airpcap_adapter</a>  (const char *name)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000160"></a>Global <a class="el" href="winpkt_8c.html#a4453de12a4c726185d042d1282fe531b">open_wanpacket_adapter</a>  (const char *name)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000075"></a>File <a class="el" href="pcigmp_8c.html">pcigmp.c</a>  </dt>
<dd>Support IGMP v3 (draft-ietf-idmr-igmp-v3-??.txt)  </dd>
<dt><a class="anchor" id="_todo000079"></a>Global <a class="el" href="pcpkt_8c.html#ad635d7372ef69250f6dc7791030791ec">pkt_api_entry</a>  (<a class="el" href="struct_i_r_e_g_s.html">IREGS</a> *reg, unsigned line)</dt>
<dd>Use 32-bit API; accessing card via pmode driver  </dd>
<dt><a class="anchor" id="_todo000154"></a>Global <a class="el" href="winpkt_8c.html#a704aee59a8a2dcd2aa9ee41a4ec53b83">pkt_eth_init</a>  (mac_address *mac_addr)</dt>
<dd>Support Win-9x/ME/CE too  </dd>
<dt><a class="anchor" id="_todo000154"></a>Global <a class="el" href="winpkt_8c.html#a704aee59a8a2dcd2aa9ee41a4ec53b83">pkt_eth_init</a>  (mac_address *mac_addr)</dt>
<dd>Support Win-9x/ME/CE too  </dd>
<dt><a class="anchor" id="_todo000076"></a>Global <a class="el" href="winpkt_8c.html#a00412dc2b7fcd45a9f77e8a6e65d85e8">pkt_release</a>  (void)</dt>
<dd>We might be called between 1st and 2nd packet-driver upcall. Need to wait for 2nd upcall to finish or else freeing the RMCB too early could cause a crash or a stuck PKTDRVR.  </dd>
<dt><a class="anchor" id="_todo000077"></a>Global <a class="el" href="winpkt_8c.html#afcf7522903bb15a8906452ac2d8c69ef">pkt_send</a>  (const void *tx, int length)</dt>
<dd>Change this so that we doesn't retry if the driver was stuck for "too long". I've seen drivers using approx. 100 msec on each iteration below. Retrying if the driver is stuck is not worth the time.  </dd>
<dt><a class="anchor" id="_todo000156"></a>Global <a class="el" href="winpkt_8c.html#a03a03330927f665d06a1b3079aa448b3">pkt_strerror</a>  (int code)</dt>
<dd>Return strings for these: PDERR_GEN_FAIL PDERR_NO_DRIVER PDERR_NO_CLASS PDERR_NO_MULTICAST PDERR_NO_SPACE<ul>
<li>GetLastError(). Use <a class="el" href="winmisc_8c.html#a93a689b6ce11c55d0f250801e0d4bee9" title="Return err-number and string for &#39;err&#39;. ">win_strerror()</a>  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000164"></a>Global <a class="el" href="x32vm_8c.html#a59e92c33a12e5037b4e4c45df51d3013">PmGlueEnd</a>  (void)</dt>
<dd>Support 32-bit Watcom with X32VM  </dd>
<dt><a class="anchor" id="_todo000100"></a>Global <a class="el" href="pppoe_8h.html#ae36690660543f80c2eeefbcd11122a1d">pppoe_start</a>  (void)</dt>
<dd>Fix-me: The new MTU/MSS affects all connections (also those which doesn't use PPPoE framing).  </dd>
<dt><a class="anchor" id="_todo000046"></a>Global <a class="el" href="netaddr_8c.html#a1f8af5184e492c2ad456994184d55841">priv_addr</a>  (DWORD ip)</dt>
<dd>: rewrite using mask_len().  </dd>
<dt><a class="anchor" id="_todo000146"></a>Global <a class="el" href="udp__rev_8c.html#a3b9d674e06d0868f4f0eb2a6b69db313">query_init_ip6</a>  (struct <a class="el" href="struct_d_n_s__query.html">DNS_query</a> *q, const void *addr)</dt>
<dd>Use "ip6.arpa" bitstring format ?  </dd>
<dt><a class="anchor" id="_todo000133"></a>Global <a class="el" href="sockopt_8c.html#ab353d8662fba00693eab53a7193f7a56">raw6_rx_buf</a>  (<a class="el" href="struct__raw6___socket.html">_raw6_Socket</a> *raw, DWORD size)</dt>
<dd>Support setting Rx-buffer size of raw IPv6 sockets  </dd>
<dt><a class="anchor" id="_todo000134"></a>Global <a class="el" href="sockopt_8c.html#aa1dd2ef9183beae1f10134a1fabb746a">raw6_tx_buf</a>  (<a class="el" href="struct__raw6___socket.html">_raw6_Socket</a> *raw, DWORD size)</dt>
<dd>Support setting Tx-buffer size of raw IPv6 sockets  </dd>
<dt><a class="anchor" id="_todo000131"></a>Global <a class="el" href="sockopt_8c.html#a7ab4bdd03af89f89fdf49da41713a231">raw_rx_buf</a>  (<a class="el" href="struct__raw___socket.html">_raw_Socket</a> *raw, DWORD size)</dt>
<dd>Support setting Rx-buffer size of raw IPv4 sockets  </dd>
<dt><a class="anchor" id="_todo000132"></a>Global <a class="el" href="sockopt_8c.html#a19c55e74cbff9e0ab8c77b2ef184f2db">raw_tx_buf</a>  (<a class="el" href="struct__raw___socket.html">_raw_Socket</a> *raw, DWORD size)</dt>
<dd>Support setting Tx-buffer size of raw IPv4 sockets  </dd>
<dt><a class="anchor" id="_todo000012"></a>Global <a class="el" href="geteth_8c.html#ad5a00c80b524ae2b8e131ef00ae31b3f">ReadEthersFile</a>  (void)</dt>
<dd>: Assert that.  </dd>
<dt><a class="anchor" id="_todo000104"></a>Global <a class="el" href="res__mkqu_8c.html#adb419d7980119db1b0285bbc3230f224">res_mkquery</a>  (int op, const char *dname, int Class, int type, const u_char *data, int datalen, const u_char *newrr_in, u_char *buf, int buflen)</dt>
<dd>Handle STATUS case  </dd>
<dt><a class="anchor" id="_todo000104"></a>Global <a class="el" href="res__mkqu_8c.html#adb419d7980119db1b0285bbc3230f224">res_mkquery</a>  (int op, const char *dname, int Class, int type, const u_char *data, int datalen, const u_char *newrr_in, u_char *buf, int buflen)</dt>
<dd>Handle STATUS case  </dd>
<dt><a class="anchor" id="_todo000162"></a>Global <a class="el" href="x32vm_8c.html#a266fdd48e18b05a66d2e0c7e8bb4dc48">rmcb</a>  [MAX_WRAPPERS]</dt>
<dd>find the real application start  </dd>
<dt><a class="anchor" id="_todo000051"></a>Class <a class="el" href="structroute__entry.html">route_entry</a>  </dt>
<dd>: Move to route.c  </dd>
<dt><a class="anchor" id="_todo000081"></a>Global <a class="el" href="pcsarp_8c.html#a17bde5ebc2159dcf6924d607361ff7dc">sarp_receive</a>  (const struct <a class="el" href="structsarp___packet.html">sarp_Packet</a> *sarp)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000106"></a>Global <a class="el" href="select_8c.html#a1a59922cb35db3c2c5e4111ac83a8e09">sel_min_block</a>  </dt>
<dd>Should be configurable.  </dd>
<dt><a class="anchor" id="_todo000122"></a>Global <a class="el" href="socket_8c.html#ae6f41cf4e032540ba1f0959ea161c59d">set_proto</a>  (int type, BOOL is_ip6, int *proto)</dt>
<dd>IPPROTO_XTP  </dd>
<dt><a class="anchor" id="_todo000065"></a>Global <a class="el" href="pcdhcp_8c.html#a6041a2ef8a545c9964b07c576df1ecb3">set_vend_class</a>  (const char *value)</dt>
<dd>Support setting vendor class  </dd>
<dt><a class="anchor" id="_todo000007"></a>Global <a class="el" href="bsdname_8c.html#a18727ad53e297c07da25f31698979a06">sethostname</a>  (const char *fqdn, SETHOSTNAME_ARG2 len)</dt>
<dd>: should do complete alpha/digit/underscore check here  </dd>
<dt><a class="anchor" id="_todo000078"></a>Global <a class="el" href="pcpkt_8c.html#af9bd7fa7e6b9f7b772b205a8e6dce96b">setup_pkt_inf</a>  (void)</dt>
<dd>Make dynamic allocation based on 'pkt_num_rx_bufs'. Allocate multiple 64kB blocks if needed (would involve messy 16-bit coding in asmpkt.nas).  </dd>
<dt><a class="anchor" id="_todo000108"></a>Global <a class="el" href="inc_2sys_2socket_8h.html#ad65efa2c991b6b9b08ffd0f03ee253bd">shutdown</a>  (int, int)</dt>
<dd><p class="startdd">For tcp, should send RST if we get incoming data. Don't send ICMP error. </p>
<p class="enddd">For tcp, should send FIN when all Tx data has been ack'ed. close_s(s) should be same as shutdown(s,SHUT_WR)  </p>
</dd>
<dt><a class="anchor" id="_todo000108"></a>Global <a class="el" href="inc_2sys_2socket_8h.html#ad65efa2c991b6b9b08ffd0f03ee253bd">shutdown</a>  (int, int)</dt>
<dd><p class="startdd">For tcp, should send RST if we get incoming data. Don't send ICMP error. </p>
<p class="enddd">For tcp, should send FIN when all Tx data has been ack'ed. close_s(s) should be same as shutdown(s,SHUT_WR)  </p>
</dd>
<dt><a class="anchor" id="_todo000116"></a>Global <a class="el" href="sock__io_8c.html#a6071fd36728cbfd06bb487f8abe9c3c1">sock_getcw</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s)</dt>
<dd>Wide character version of sock_getc()  </dd>
<dt><a class="anchor" id="_todo000115"></a>Global <a class="el" href="sock__io_8c.html#a0cd06ffa9992677d227785cd19142b88">sock_getsw</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s, wchar_t *data, int n)</dt>
<dd>Wide character version of sock_gets()  </dd>
<dt><a class="anchor" id="_todo000119"></a>Global <a class="el" href="src_2socket_8h.html#a924918ec15b1f709506ee33b7e7810aa">sock_packet_receive</a>  (<a class="el" href="struct_socket.html">Socket</a> *sock, void *buf, unsigned len, struct sockaddr *from, size_t *fromlen)</dt>
<dd><p class="startdd">This should loop until some packet is received. </p>
<p class="enddd">should check fromlen is large enough  </p>
</dd>
<dt><a class="anchor" id="_todo000113"></a>Global <a class="el" href="sock__io_8c.html#a66727fb704b7f1d45ee998e13e79f79a">sock_putcw</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s, wchar_t ch)</dt>
<dd>Wide character versions of above functions. </dd>
<dt><a class="anchor" id="_todo000112"></a>Global <a class="el" href="sock__io_8c.html#ae5f86f57a584eeaa62a2cdb29fc13e52">sock_puts</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s, const BYTE *data)</dt>
<dd>suppport UDP frags  </dd>
<dt><a class="anchor" id="_todo000112"></a>Global <a class="el" href="sock__io_8c.html#ae5f86f57a584eeaa62a2cdb29fc13e52">sock_puts</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s, const BYTE *data)</dt>
<dd>suppport UDP frags  </dd>
<dt><a class="anchor" id="_todo000114"></a>Global <a class="el" href="sock__io_8c.html#a3c16ad15fd1a74a57324e2073f7186be">sock_putsw</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s, const wchar_t *data)</dt>
<dd>Wide character version of <a class="el" href="sock__io_8c.html#ae5f86f57a584eeaa62a2cdb29fc13e52">sock_puts()</a>  </dd>
<dt><a class="anchor" id="_todo000121"></a>Global <a class="el" href="socket_8c.html#ac9dba9d57acafd39b5c5fd37cddf8b83">sock_raw4_recv</a>  (const <a class="el" href="structin___header.html">in_Header</a> *ip)</dt>
<dd>Handle receiving bad IP-packets for SOCK_RAW sockets.  </dd>
<dt><a class="anchor" id="_todo000135"></a>Global <a class="el" href="split_8c.html#a9a6817ed7bb2c6331cb4c2aba5514d3e">split_ip6</a>  (struct <a class="el" href="structpkt__split.html">pkt_split</a> *, const <a class="el" href="structin6___header.html">in6_Header</a> *)</dt>
<dd>Handle Fragment, ESP, <a class="el" href="struct_a_u_t_h.html">AUTH</a>, IPv6 encap  </dd>
<dt><a class="anchor" id="_todo000099"></a>Global <a class="el" href="ppp_8c.html#ad908cca0f494c553509977826c6b4b08">std_negotiation</a>  (struct <a class="el" href="structppp__state.html">ppp_state</a> *state, struct <a class="el" href="structppp__xcp.html">ppp_xcp</a> *xcp)</dt>
<dd>extract LCP_MRU option  </dd>
<dt><a class="anchor" id="_todo000136"></a>File <a class="el" href="syslog_8c.html">syslog.c</a>  </dt>
<dd>configure variables in <a class="el" href="syslog2_8c.html">syslog2.c</a> when calling openlog() thus making syslog() independent of <a class="el" href="sock__ini_8c.html#ad07fd2012bb92d1421885ac94cc9e9f5">watt_sock_init()</a>.  </dd>
<dt><a class="anchor" id="_todo000092"></a>Global <a class="el" href="pctcp_8c.html#a61003b3891c22ba24b707d0f02248a49">tcp_listen</a>  (_tcp_Socket *s, WORD lport, DWORD ip, WORD port, ProtoHandler handler, WORD timeout)</dt>
<dd>use <b>mss</b> from setsockopt()  </dd>
<dt><a class="anchor" id="_todo000092"></a>Global <a class="el" href="pctcp_8c.html#a61003b3891c22ba24b707d0f02248a49">tcp_listen</a>  (_tcp_Socket *s, WORD lport, DWORD ip, WORD port, ProtoHandler handler, WORD timeout)</dt>
<dd>use <b>mss</b> from setsockopt()  </dd>
<dt><a class="anchor" id="_todo000090"></a>Global <a class="el" href="pctcp_8c.html#ad3ab18774baa34ab715362614c1cbb93">tcp_open</a>  (_tcp_Socket *s, WORD lport, DWORD ip, WORD rport, ProtoHandler handler)</dt>
<dd><p class="startdd">use <b>mss</b> from setsockopt() </p>
<p class="enddd">use <b>TCP_NODELAY</b> set in setsockopt()  </p>
</dd>
<dt><a class="anchor" id="_todo000090"></a>Global <a class="el" href="pctcp_8c.html#ad3ab18774baa34ab715362614c1cbb93">tcp_open</a>  (_tcp_Socket *s, WORD lport, DWORD ip, WORD rport, ProtoHandler handler)</dt>
<dd><p class="startdd">use <b>mss</b> from setsockopt() </p>
<p class="enddd">use <b>TCP_NODELAY</b> set in setsockopt()  </p>
</dd>
<dt><a class="anchor" id="_todo000138"></a>Global <a class="el" href="tcp__fsm_8c.html#ad483f7bf87dc16085aa71f25f1f5afb1">tcp_process_data</a>  (_tcp_Socket *s, const <a class="el" href="structtcp___header.html">tcp_Header</a> *tcp, int len, int *flags)</dt>
<dd>Handle Out-of-Order urgent data. Raise SIGURG.  </dd>
<dt><a class="anchor" id="_todo000139"></a>Global <a class="el" href="tcp__fsm_8c.html#a9e0dbce1f0b16cb31c50257f703c64c8">tcp_reassemble</a>  (_tcp_Socket *s, const <a class="el" href="structtcp___header.html">tcp_Header</a> *tcp, const BYTE *data, UINT len, int *flags)</dt>
<dd>Create a better TCP reassembler some day. </dd>
<dt><a class="anchor" id="_todo000102"></a>Global <a class="el" href="receive_8c.html#aa0ed09d834e3ae9bf87c05317122189e">tcp_receive</a>  (<a class="el" href="struct_socket.html">Socket</a> *sock, void *buf, int len, int flags, struct sockaddr *from, size_t *fromlen)</dt>
<dd>Handle receiving Out-of-Band data  </dd>
<dt><a class="anchor" id="_todo000094"></a>Global <a class="el" href="pctcp_8h.html#a21f43244bafa5dc4a49f390fc9d0e96e">tcp_Retransmitter</a>  (BOOL force)</dt>
<dd><p class="startdd">set "Slow-start" threshold </p>
<p class="enddd">Allow for 3 SYN before giving up  </p>
</dd>
<dt><a class="anchor" id="_todo000097"></a>Global <a class="el" href="pctcp_8c.html#a553f9220c56e51890f7501d389e11a99">tcp_rtt_win</a>  (_tcp_Socket *s)</dt>
<dd>Use the threshold to signify "end-of-Slow-Start" (equilibrium)  </dd>
<dt><a class="anchor" id="_todo000148"></a>Global <a class="el" href="structtcp___socket.html#a9c8c4dd6bf7a84e61d6d2b2017f6b925">tcp_Socket::missed_seq</a>  [2]</dt>
<dd>Make a proper re-assembly queue. missed_seq[0] is left edge of missing segment. missed_seq[1] is right edge (in peer's absolute SEQ space)  </dd>
<dt><a class="anchor" id="_todo000149"></a>Global <a class="el" href="structtcp___socket.html#a17fffa8747a9df398c0485d36a00969c">tcp_Socket::tx_wscale</a>  </dt>
<dd>window scales shifts, Tx/Rx  </dd>
<dt><a class="anchor" id="_todo000137"></a>Global <a class="el" href="tcp__fsm_8c.html#a2d527f9703c320f33d2cc6f776d617a1">tcp_synsent_state</a>  (_tcp_Socket **, const <a class="el" href="structin___header.html">in_Header</a> *, <a class="el" href="structtcp___header.html">tcp_Header</a> *, int)</dt>
<dd>recalculate RTT-timer  </dd>
<dt><a class="anchor" id="_todo000096"></a>Global <a class="el" href="pctcp_8c.html#a5db19271d908ae67bcfebf2499c6a666">tcp_tick</a>  (<a class="el" href="unionsock__type.html">sock_type</a> *s)</dt>
<dd>Limit the time spent here (clamp # of loops)  </dd>
<dt><a class="anchor" id="_todo000143"></a>Global <a class="el" href="transmit_8c.html#ab0b8b1c69e2309b3216e02d0eb8e8459">tcp_transmit</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, const void *buf, unsigned len, int flags)</dt>
<dd>Allow non-blocking sockets to send in SYNSENT state  </dd>
<dt><a class="anchor" id="_todo000140"></a>File <a class="el" href="tftp_8c.html">tftp.c</a>  </dt>
<dd>Support option negotiation and ETFTP (RFC-1986)  </dd>
<dt><a class="anchor" id="_todo000141"></a>File <a class="el" href="timer_8c.html">timer.c</a>  </dt>
<dd>To get rid of the timer problem once and for all we need a timer ISR that increments a 32-bit value no regard to day roll-over etc. Maybe hook up IRQ 8 to call a real-mode stub that we opy to DOS-memory (similar to the pkt_receiver stub code. Then far-peek at that timer variable. </dd>
<dt><a class="anchor" id="_todo000022"></a>Global <a class="el" href="ioctl_8c.html#a5f37d754923867cb63d67eb5a4fdef06">tok_ifnet</a>  (void)</dt>
<dd>fill info  </dd>
<dt><a class="anchor" id="_todo000093"></a>Global <a class="el" href="pctcp_8c.html#aba36f21d6b0c713d872f9b5820367cf4">udp_demux</a>  (const <a class="el" href="structin___header.html">in_Header</a> *ip, BOOL ip_bcast, DWORD destin, WORD srcPort, WORD dstPort, BOOL *udp_err)</dt>
<dd>use some kind of hashing to speed up the search.  </dd>
<dt><a class="anchor" id="_todo000040"></a>Global <a class="el" href="loopback_8c.html#a493f5fcc31968933cc7b1aaf37802c01">udp_loopback</a>  (<a class="el" href="structudp___header.html">udp_Header</a> *udp, unsigned udp_len)</dt>
<dd><p class="startdd">UDP loopback handler should handle ECHO protocol </p>
<p class="enddd">UDP loopback handler should handle DISCARD protocol  </p>
</dd>
<dt><a class="anchor" id="_todo000103"></a>Global <a class="el" href="receive_8c.html#a78f88eb3d4fbd3d03c63e7037e3e91df">udp_receive</a>  (<a class="el" href="struct_socket.html">Socket</a> *sock, void *buf, int len, int flags, struct sockaddr *from, size_t *fromlen)</dt>
<dd>This needs a redesign  </dd>
<dt><a class="anchor" id="_todo000084"></a>Global <a class="el" href="pcstat_8h.html#aef58a6386e247e21975d7dd2c0f1a55f">update_in_stat</a>  (void)</dt>
<dd><p class="startdd">Count PPP protocols LCP and IPCP </p>
<p class="enddd">Count these IPv6 protocols  </p>
</dd>
<dt><a class="anchor" id="_todo000086"></a>Global <a class="el" href="pcstat_8h.html#ad86c5cae55bdc7669d5a0e6a4d6a35c2">update_out_stat</a>  (void)</dt>
<dd><p class="startdd">Count the PPP protocols LCP and IPCP </p>
<p class="enddd">Count these IPv6 protocols  </p>
</dd>
<dt><a class="anchor" id="_todo000101"></a>Global <a class="el" href="pppoe_8c.html#a3ad9948d18b6a0eda4c7591cd4b43b46">user_name</a>  [MAX_VALUELEN+1]</dt>
<dd>PPP user/passwd not handled  </dd>
<dt><a class="anchor" id="_todo000028"></a>Global <a class="el" href="ioctl_8c.html#ac710e95198b4eaa73d921d663df88661">waterm_ioctrl</a>  (<a class="el" href="struct_socket.html">Socket</a> *socket, long cmd, char *argp)</dt>
<dd><p class="startdd">set high watermark </p>
<p>get high watermark </p>
<p>set low watermark </p>
<p>get low watermark </p>
<p class="enddd">OOB data available?  </p>
</dd>
<dt><a class="anchor" id="_todo000111"></a>Global <a class="el" href="sock__ini_8c.html#ad07fd2012bb92d1421885ac94cc9e9f5">watt_sock_init</a>  (size_t tcp_Sock_size, size_t udp_Sock_size, size_t time_t_size)</dt>
<dd>Use auto-configuration and set 'my_ip_addr' to 169.254/16  </dd>
<dt><a class="anchor" id="_todo000155"></a>Global <a class="el" href="winpkt_8c.html#ad62e99cfe9492a3d2857951588c4cddf">winpcap_recv_thread</a>  (void *arg)</dt>
<dd>: Take the 'adapter' info from 'arg' instead of using the global '_pkt_inf' structure. </dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
