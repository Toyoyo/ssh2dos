<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Watt-32 tcp/ip: /home/fosco/src/SSH2DOS/watt32/src/pctcp.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Watt-32 tcp/ip
   &#160;<span id="projectnumber">2.2 dev-rel.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pctcp_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pctcp.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="pctcp_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structip6__packet.html">ip6_packet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcp__pkt.html">tcp_pkt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcp6__pkt.html">tcp6_pkt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7f0d6900c1b13317764121fcdb6833e1"><td class="memItemLeft" align="right" valign="top"><a id="a7f0d6900c1b13317764121fcdb6833e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>W32_CLANG_PACK_WARN_OFF</b> ()</td></tr>
<tr class="separator:a7f0d6900c1b13317764121fcdb6833e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4920f50e4b4a67ad4d5af783e020a9d6"><td class="memItemLeft" align="right" valign="top"><a id="a4920f50e4b4a67ad4d5af783e020a9d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>W32_CLANG_PACK_WARN_DEF</b> ()</td></tr>
<tr class="separator:a4920f50e4b4a67ad4d5af783e020a9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e365b2058c8ce00c89befc10176b06"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ae8e365b2058c8ce00c89befc10176b06">udp_open</a> (_udp_Socket *s, WORD lport, DWORD ip, WORD port, ProtoHandler handler)</td></tr>
<tr class="memdesc:ae8e365b2058c8ce00c89befc10176b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">UDP active open.  <a href="#ae8e365b2058c8ce00c89befc10176b06">More...</a><br /></td></tr>
<tr class="separator:ae8e365b2058c8ce00c89befc10176b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34839a2d192a5542548507755ef3e91"><td class="memItemLeft" align="right" valign="top"><a id="ac34839a2d192a5542548507755ef3e91"></a>
static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ac34839a2d192a5542548507755ef3e91">udp_close</a> (const _udp_Socket *udp)</td></tr>
<tr class="memdesc:ac34839a2d192a5542548507755ef3e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since UDP is stateless, simply reclaim the local-port and unthread the socket from the list. <br /></td></tr>
<tr class="separator:ac34839a2d192a5542548507755ef3e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99b8b9e5f36ae40702370660364f8ed"><td class="memItemLeft" align="right" valign="top"><a id="ae99b8b9e5f36ae40702370660364f8ed"></a>
int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ae99b8b9e5f36ae40702370660364f8ed">udp_SetTTL</a> (_udp_Socket *s, BYTE ttl)</td></tr>
<tr class="memdesc:ae99b8b9e5f36ae40702370660364f8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TTL on an outgoing UDP datagram. <br /></td></tr>
<tr class="separator:ae99b8b9e5f36ae40702370660364f8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab18774baa34ab715362614c1cbb93"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ad3ab18774baa34ab715362614c1cbb93">tcp_open</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, WORD lport, DWORD ip, WORD rport, ProtoHandler handler)</td></tr>
<tr class="memdesc:ad3ab18774baa34ab715362614c1cbb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actively open a TCP connection.  <a href="#ad3ab18774baa34ab715362614c1cbb93">More...</a><br /></td></tr>
<tr class="separator:ad3ab18774baa34ab715362614c1cbb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61003b3891c22ba24b707d0f02248a49"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a61003b3891c22ba24b707d0f02248a49">tcp_listen</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, WORD lport, DWORD ip, WORD port, ProtoHandler handler, WORD timeout)</td></tr>
<tr class="memdesc:a61003b3891c22ba24b707d0f02248a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passively opens TCP a connection.  <a href="#a61003b3891c22ba24b707d0f02248a49">More...</a><br /></td></tr>
<tr class="separator:a61003b3891c22ba24b707d0f02248a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d6937123b2ce65acec05cc9fea7954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ac2d6937123b2ce65acec05cc9fea7954">_tcp_close</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s)</td></tr>
<tr class="memdesc:ac2d6937123b2ce65acec05cc9fea7954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a TCP connection.  <a href="#ac2d6937123b2ce65acec05cc9fea7954">More...</a><br /></td></tr>
<tr class="separator:ac2d6937123b2ce65acec05cc9fea7954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcde308a20f3f4620c00063d6a16f0c"><td class="memItemLeft" align="right" valign="top"><a id="aefcde308a20f3f4620c00063d6a16f0c"></a>
<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#aefcde308a20f3f4620c00063d6a16f0c">_tcp_abort</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, const char *file, unsigned line)</td></tr>
<tr class="memdesc:aefcde308a20f3f4620c00063d6a16f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a TCP connection. <br /></td></tr>
<tr class="separator:aefcde308a20f3f4620c00063d6a16f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaf3d256d88a1c954dfeadaeac88fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#aafaf3d256d88a1c954dfeadaeac88fa0">_tcp_sendsoon</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, const char *file, unsigned line)</td></tr>
<tr class="memdesc:aafaf3d256d88a1c954dfeadaeac88fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a transmission pretty soon.  <a href="#aafaf3d256d88a1c954dfeadaeac88fa0">More...</a><br /></td></tr>
<tr class="separator:aafaf3d256d88a1c954dfeadaeac88fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b3d5890e3d9d2428199de059f913a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ac8b3d5890e3d9d2428199de059f913a0">_tcp_unthread</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *ds, BOOL free_tx)</td></tr>
<tr class="memdesc:ac8b3d5890e3d9d2428199de059f913a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unthread a socket from the tcp socket list, if it's there.  <a href="#ac8b3d5890e3d9d2428199de059f913a0">More...</a><br /></td></tr>
<tr class="separator:ac8b3d5890e3d9d2428199de059f913a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e0de65401ff444abd6955a1e52be4d"><td class="memItemLeft" align="right" valign="top"><a id="a06e0de65401ff444abd6955a1e52be4d"></a>
int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a06e0de65401ff444abd6955a1e52be4d">tcp_established</a> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s)</td></tr>
<tr class="memdesc:a06e0de65401ff444abd6955a1e52be4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if TCP connection is established. <br /></td></tr>
<tr class="separator:a06e0de65401ff444abd6955a1e52be4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44799073c1591d7991ebf101cd5d46d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a44799073c1591d7991ebf101cd5d46d0">_tcp_handler</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, BOOL broadcast)</td></tr>
<tr class="memdesc:a44799073c1591d7991ebf101cd5d46d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main TCP input handler.  <a href="#a44799073c1591d7991ebf101cd5d46d0">More...</a><br /></td></tr>
<tr class="separator:a44799073c1591d7991ebf101cd5d46d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb5d8961fe8919916dbda4f10ed1372"><td class="memItemLeft" align="right" valign="top"><a id="affb5d8961fe8919916dbda4f10ed1372"></a>
static BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#affb5d8961fe8919916dbda4f10ed1372">udp_checksum</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, const <a class="el" href="structudp___header.html">udp_Header</a> *udp, int len)</td></tr>
<tr class="memdesc:affb5d8961fe8919916dbda4f10ed1372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify checksum for an UDP packet. <br /></td></tr>
<tr class="separator:affb5d8961fe8919916dbda4f10ed1372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba36f21d6b0c713d872f9b5820367cf4"><td class="memItemLeft" align="right" valign="top">static _udp_Socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#aba36f21d6b0c713d872f9b5820367cf4">udp_demux</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, BOOL ip_bcast, DWORD destin, WORD srcPort, WORD dstPort, BOOL *udp_err)</td></tr>
<tr class="memdesc:aba36f21d6b0c713d872f9b5820367cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demultiplexer for incoming UDP packets.  <a href="#aba36f21d6b0c713d872f9b5820367cf4">More...</a><br /></td></tr>
<tr class="separator:aba36f21d6b0c713d872f9b5820367cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f72a10aefe2e909351b6c847938c78"><td class="memItemLeft" align="right" valign="top"><a id="ac5f72a10aefe2e909351b6c847938c78"></a>
_udp_Socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ac5f72a10aefe2e909351b6c847938c78">_udp_handler</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, BOOL broadcast)</td></tr>
<tr class="memdesc:ac5f72a10aefe2e909351b6c847938c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for incoming UDP packets. <br /></td></tr>
<tr class="separator:ac5f72a10aefe2e909351b6c847938c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f43244bafa5dc4a49f390fc9d0e96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a21f43244bafa5dc4a49f390fc9d0e96e">tcp_Retransmitter</a> (BOOL force)</td></tr>
<tr class="memdesc:a21f43244bafa5dc4a49f390fc9d0e96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called periodically to perform retransmissions.  <a href="#a21f43244bafa5dc4a49f390fc9d0e96e">More...</a><br /></td></tr>
<tr class="separator:a21f43244bafa5dc4a49f390fc9d0e96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db19271d908ae67bcfebf2499c6a666"><td class="memItemLeft" align="right" valign="top">WORD W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a5db19271d908ae67bcfebf2499c6a666">tcp_tick</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s)</td></tr>
<tr class="memdesc:a5db19271d908ae67bcfebf2499c6a666"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Must</b> be called periodically by user application (or BSD socket API).  <a href="#a5db19271d908ae67bcfebf2499c6a666">More...</a><br /></td></tr>
<tr class="separator:a5db19271d908ae67bcfebf2499c6a666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7ba67c879b514ea6f19c8ddb7abdbc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ada7ba67c879b514ea6f19c8ddb7abdbc">udp_write</a> (_udp_Socket *s, const BYTE *data, int len)</td></tr>
<tr class="memdesc:ada7ba67c879b514ea6f19c8ddb7abdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an UDP packet.  <a href="#ada7ba67c879b514ea6f19c8ddb7abdbc">More...</a><br /></td></tr>
<tr class="separator:ada7ba67c879b514ea6f19c8ddb7abdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b797c7ad66da39463844059ca6ff8d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a25b797c7ad66da39463844059ca6ff8d">udp_read</a> (_udp_Socket *s, BYTE *buf, int maxlen)</td></tr>
<tr class="memdesc:a25b797c7ad66da39463844059ca6ff8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from UDP socket.  <a href="#a25b797c7ad66da39463844059ca6ff8d">More...</a><br /></td></tr>
<tr class="separator:a25b797c7ad66da39463844059ca6ff8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab13fbf4fc455cf1d5ecf1d1771b899"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a6ab13fbf4fc455cf1d5ecf1d1771b899">sock_reduce_mss</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s, WORD MTU)</td></tr>
<tr class="memdesc:a6ab13fbf4fc455cf1d5ecf1d1771b899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce socket MSS upon receiving ICMP_UNREACH_NEEDFRAG.  <a href="#a6ab13fbf4fc455cf1d5ecf1d1771b899">More...</a><br /></td></tr>
<tr class="separator:a6ab13fbf4fc455cf1d5ecf1d1771b899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad09b4f7b662a0ebecfb634f454598a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#aaad09b4f7b662a0ebecfb634f454598a">_udp_cancel</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, int icmp_type, int icmp_code, const char *msg, const <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> *arg)</td></tr>
<tr class="memdesc:aaad09b4f7b662a0ebecfb634f454598a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an UDP socket.  <a href="#aaad09b4f7b662a0ebecfb634f454598a">More...</a><br /></td></tr>
<tr class="separator:aaad09b4f7b662a0ebecfb634f454598a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0569fa9bec72a088e07cf8c51860a7dc"><td class="memItemLeft" align="right" valign="top"><a id="a0569fa9bec72a088e07cf8c51860a7dc"></a>
static BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_stress_test</b> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, const char *msg)</td></tr>
<tr class="separator:a0569fa9bec72a088e07cf8c51860a7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334512160f11a831f74c06c390b97284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a334512160f11a831f74c06c390b97284">_tcp_cancel</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, int icmp_type, int icmp_code, const char *msg, const <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> *arg)</td></tr>
<tr class="memdesc:a334512160f11a831f74c06c390b97284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a TCP socket.  <a href="#a334512160f11a831f74c06c390b97284">More...</a><br /></td></tr>
<tr class="separator:a334512160f11a831f74c06c390b97284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145bcb229d5f15a3a6d08ce5fbb1f93e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a145bcb229d5f15a3a6d08ce5fbb1f93e">tcp_read</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BYTE *buf, int maxlen)</td></tr>
<tr class="memdesc:a145bcb229d5f15a3a6d08ce5fbb1f93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a TCP socket.  <a href="#a145bcb229d5f15a3a6d08ce5fbb1f93e">More...</a><br /></td></tr>
<tr class="separator:a145bcb229d5f15a3a6d08ce5fbb1f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f30c2a196fc4212def321259ee308c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a16f30c2a196fc4212def321259ee308c">tcp_write</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, const BYTE *data, UINT len)</td></tr>
<tr class="memdesc:a16f30c2a196fc4212def321259ee308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a TCP connection.  <a href="#a16f30c2a196fc4212def321259ee308c">More...</a><br /></td></tr>
<tr class="separator:a16f30c2a196fc4212def321259ee308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87603e52116e948bf338dbf8f88e9c16"><td class="memItemLeft" align="right" valign="top"><a id="a87603e52116e948bf338dbf8f88e9c16"></a>
static <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a87603e52116e948bf338dbf8f88e9c16">tcp_findseq</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, const <a class="el" href="structtcp___header.html">tcp_Header</a> *tcp)</td></tr>
<tr class="memdesc:a87603e52116e948bf338dbf8f88e9c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the TCP socket that matches the tripplet: <code>DESTADDR=MYADDR</code>, <code>DESTPORT=MYPORT</code> and <code>ACKNUM=SEQNUM+1</code> Can only be one socket. <br /></td></tr>
<tr class="separator:a87603e52116e948bf338dbf8f88e9c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60d985c111b273298766ac7e9b392a0"><td class="memItemLeft" align="right" valign="top"><a id="aa60d985c111b273298766ac7e9b392a0"></a>
static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#aa60d985c111b273298766ac7e9b392a0">tcp_sockreset</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BOOL proxy)</td></tr>
<tr class="memdesc:aa60d985c111b273298766ac7e9b392a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a TCP connection. <br /></td></tr>
<tr class="separator:aa60d985c111b273298766ac7e9b392a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99f8eda55106ab449f7addc3efe5458"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ab99f8eda55106ab449f7addc3efe5458">tcp_no_arp</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s)</td></tr>
<tr class="memdesc:ab99f8eda55106ab449f7addc3efe5458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called for a TCP socket when ARP lookup fails.  <a href="#ab99f8eda55106ab449f7addc3efe5458">More...</a><br /></td></tr>
<tr class="separator:ab99f8eda55106ab449f7addc3efe5458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17ad983a90a10796a8601a4c1b90d80"><td class="memItemLeft" align="right" valign="top">static BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ab17ad983a90a10796a8601a4c1b90d80">tcp_checksum</a> (const <a class="el" href="structin___header.html">in_Header</a> *ip, const <a class="el" href="structtcp___header.html">tcp_Header</a> *tcp, int len)</td></tr>
<tr class="memdesc:ab17ad983a90a10796a8601a4c1b90d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the TCP header checksum.  <a href="#ab17ad983a90a10796a8601a4c1b90d80">More...</a><br /></td></tr>
<tr class="separator:ab17ad983a90a10796a8601a4c1b90d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553f9220c56e51890f7501d389e11a99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a553f9220c56e51890f7501d389e11a99">tcp_rtt_win</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s)</td></tr>
<tr class="memdesc:a553f9220c56e51890f7501d389e11a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update retransmission timer, VJ algorithm and TCP windows.  <a href="#a553f9220c56e51890f7501d389e11a99">More...</a><br /></td></tr>
<tr class="separator:a553f9220c56e51890f7501d389e11a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967225f4fc5c1feab9d513dffaa3e79c"><td class="memItemLeft" align="right" valign="top"><a id="a967225f4fc5c1feab9d513dffaa3e79c"></a>
static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a967225f4fc5c1feab9d513dffaa3e79c">tcp_upd_win</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, unsigned line)</td></tr>
<tr class="memdesc:a967225f4fc5c1feab9d513dffaa3e79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if receive window needs an update. <br /></td></tr>
<tr class="separator:a967225f4fc5c1feab9d513dffaa3e79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750496d700acf8452af305385a518f53"><td class="memItemLeft" align="right" valign="top">static __inline int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a750496d700acf8452af305385a518f53">tcp_opt_maxsegment</a> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BYTE *opt)</td></tr>
<tr class="memdesc:a750496d700acf8452af305385a518f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP option routines.  <a href="#a750496d700acf8452af305385a518f53">More...</a><br /></td></tr>
<tr class="separator:a750496d700acf8452af305385a518f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b89a064fdf4cc61dbc20ec5feb4a06"><td class="memItemLeft" align="right" valign="top">static __inline int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ae5b89a064fdf4cc61dbc20ec5feb4a06">tcp_opt_timestamp</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BYTE *opt, DWORD ts_echo)</td></tr>
<tr class="memdesc:ae5b89a064fdf4cc61dbc20ec5feb4a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert TimeStamp option.  <a href="#ae5b89a064fdf4cc61dbc20ec5feb4a06">More...</a><br /></td></tr>
<tr class="separator:ae5b89a064fdf4cc61dbc20ec5feb4a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e8245444558015df64d9906b29b5ff"><td class="memItemLeft" align="right" valign="top"><a id="a28e8245444558015df64d9906b29b5ff"></a>
static __inline int&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_opt_md5_sign</b> (BYTE *opt)</td></tr>
<tr class="separator:a28e8245444558015df64d9906b29b5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7f26ce363e51a965b62a7d0807345d"><td class="memItemLeft" align="right" valign="top"><a id="adc7f26ce363e51a965b62a7d0807345d"></a>
static __inline <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>finalise_md5_sign</b> (const <a class="el" href="structin___header.html">in_Header</a> *ip, const <a class="el" href="structtcp___header.html">tcp_Header</a> *tcp, WORD tcp_len, const char *secret)</td></tr>
<tr class="separator:adc7f26ce363e51a965b62a7d0807345d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6d39b0e957c278b94238a45dbebc39"><td class="memItemLeft" align="right" valign="top"><a id="a3a6d39b0e957c278b94238a45dbebc39"></a>
static __inline int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a3a6d39b0e957c278b94238a45dbebc39">tcp_opt_padding</a> (BYTE *opt, int len)</td></tr>
<tr class="memdesc:a3a6d39b0e957c278b94238a45dbebc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad options to multiple of 4 bytes. <br /></td></tr>
<tr class="separator:a3a6d39b0e957c278b94238a45dbebc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c4e3cd1b1efecdf4540d110a3fbde5"><td class="memItemLeft" align="right" valign="top"><a id="a55c4e3cd1b1efecdf4540d110a3fbde5"></a>
static __inline int&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_opt_winscale</b> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BYTE *opt)</td></tr>
<tr class="separator:a55c4e3cd1b1efecdf4540d110a3fbde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f4d807b24194b37b980419b7e19d2e"><td class="memItemLeft" align="right" valign="top"><a id="a58f4d807b24194b37b980419b7e19d2e"></a>
static __inline int&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_opt_sack_ok</b> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BYTE *opt)</td></tr>
<tr class="separator:a58f4d807b24194b37b980419b7e19d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b52b80de42e015f9f28b2f40c840d7"><td class="memItemLeft" align="right" valign="top"><a id="aa1b52b80de42e015f9f28b2f40c840d7"></a>
static __inline int&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_opt_sack</b> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BYTE *opt, const struct SACK_list *sack)</td></tr>
<tr class="separator:aa1b52b80de42e015f9f28b2f40c840d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2644d69e2357c1cbc65684e0048507"><td class="memItemLeft" align="right" valign="top"><a id="a1b2644d69e2357c1cbc65684e0048507"></a>
static __inline int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a1b2644d69e2357c1cbc65684e0048507">tcp_options</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, BYTE *opt, BOOL is_syn)</td></tr>
<tr class="memdesc:a1b2644d69e2357c1cbc65684e0048507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append options to output TCP header. <br /></td></tr>
<tr class="separator:a1b2644d69e2357c1cbc65684e0048507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab214bb9c379b511b3406e9cd3e0e721"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#aab214bb9c379b511b3406e9cd3e0e721">_tcp_send</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, const char *file, unsigned line)</td></tr>
<tr class="memdesc:aab214bb9c379b511b3406e9cd3e0e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and send an outgoing TCP segment.  <a href="#aab214bb9c379b511b3406e9cd3e0e721">More...</a><br /></td></tr>
<tr class="separator:aab214bb9c379b511b3406e9cd3e0e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078bce2afb070658e8bd83346e75a097"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a078bce2afb070658e8bd83346e75a097">_tcp_send_reset</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, const <a class="el" href="structin___header.html">in_Header</a> *his_ip, const <a class="el" href="structtcp___header.html">tcp_Header</a> *org_tcp, const char *file, unsigned line)</td></tr>
<tr class="memdesc:a078bce2afb070658e8bd83346e75a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and send a reset (RST) tcp packet.  <a href="#a078bce2afb070658e8bd83346e75a097">More...</a><br /></td></tr>
<tr class="separator:a078bce2afb070658e8bd83346e75a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc3b1d4c9d1a83cf1cfeb32d4402479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a9dc3b1d4c9d1a83cf1cfeb32d4402479">_tcp_keepalive</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *tcp)</td></tr>
<tr class="memdesc:a9dc3b1d4c9d1a83cf1cfeb32d4402479"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP keepalive transmission.  <a href="#a9dc3b1d4c9d1a83cf1cfeb32d4402479">More...</a><br /></td></tr>
<tr class="separator:a9dc3b1d4c9d1a83cf1cfeb32d4402479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82dd28b60bbe1568a6b346cf265c123"><td class="memItemLeft" align="right" valign="top"><a id="af82dd28b60bbe1568a6b346cf265c123"></a>
int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><b>sock_keepalive</b> (<a class="el" href="unionsock__type.html">sock_type</a> *s)</td></tr>
<tr class="separator:af82dd28b60bbe1568a6b346cf265c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f5c6832acd7922e04f4b61368541c3"><td class="memItemLeft" align="right" valign="top"><a id="ab9f5c6832acd7922e04f4b61368541c3"></a>
WORD W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><b>sock_mode</b> (<a class="el" href="unionsock__type.html">sock_type</a> *s, WORD mode)</td></tr>
<tr class="separator:ab9f5c6832acd7922e04f4b61368541c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617de6be629621a5e56a7eafcad6c899"><td class="memItemLeft" align="right" valign="top">VoidProc W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a617de6be629621a5e56a7eafcad6c899">sock_yield</a> (<a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, VoidProc func)</td></tr>
<tr class="memdesc:a617de6be629621a5e56a7eafcad6c899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable user defined yield function.  <a href="#a617de6be629621a5e56a7eafcad6c899">More...</a><br /></td></tr>
<tr class="separator:a617de6be629621a5e56a7eafcad6c899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf7c06378339b449d75b4d6067b7ffd"><td class="memItemLeft" align="right" valign="top"><a id="a2cf7c06378339b449d75b4d6067b7ffd"></a>
int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a2cf7c06378339b449d75b4d6067b7ffd">sock_abort</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s)</td></tr>
<tr class="memdesc:a2cf7c06378339b449d75b4d6067b7ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a UDP/TCP/Raw socket. <br /></td></tr>
<tr class="separator:a2cf7c06378339b449d75b4d6067b7ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0004943f4f1ada391f7e2df76b13dd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a9f0004943f4f1ada391f7e2df76b13dd">raw_read</a> (<a class="el" href="struct__raw___socket.html">_raw_Socket</a> *raw, BYTE *buf, int maxlen)</td></tr>
<tr class="memdesc:a9f0004943f4f1ada391f7e2df76b13dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a raw-socket.  <a href="#a9f0004943f4f1ada391f7e2df76b13dd">More...</a><br /></td></tr>
<tr class="separator:a9f0004943f4f1ada391f7e2df76b13dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a2c676e1b51d281aafed877db6d0ae"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#af4a2c676e1b51d281aafed877db6d0ae">sock_read</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s, BYTE *buf, size_t maxlen)</td></tr>
<tr class="memdesc:af4a2c676e1b51d281aafed877db6d0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a socket with maximum 'maxlen' bytes.  <a href="#af4a2c676e1b51d281aafed877db6d0ae">More...</a><br /></td></tr>
<tr class="separator:af4a2c676e1b51d281aafed877db6d0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a17eaa8046675c3530efed90bbe916"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ad5a17eaa8046675c3530efed90bbe916">sock_fastread</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s, BYTE *buf, int len)</td></tr>
<tr class="memdesc:ad5a17eaa8046675c3530efed90bbe916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a socket with maximum 'len' bytes.  <a href="#ad5a17eaa8046675c3530efed90bbe916">More...</a><br /></td></tr>
<tr class="separator:ad5a17eaa8046675c3530efed90bbe916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e3ddce7d7cc17977caf0363d96f078"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a01e3ddce7d7cc17977caf0363d96f078">sock_write</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s, const BYTE *data, int len)</td></tr>
<tr class="memdesc:a01e3ddce7d7cc17977caf0363d96f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data and returns length written.  <a href="#a01e3ddce7d7cc17977caf0363d96f078">More...</a><br /></td></tr>
<tr class="separator:a01e3ddce7d7cc17977caf0363d96f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf709546a8e6963b9b288cb2bc2abaf"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a9cf709546a8e6963b9b288cb2bc2abaf">sock_fastwrite</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s, const BYTE *data, int len)</td></tr>
<tr class="memdesc:a9cf709546a8e6963b9b288cb2bc2abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, non-blocking (non-looping) version of <a class="el" href="pctcp_8c.html#a01e3ddce7d7cc17977caf0363d96f078" title="Writes data and returns length written. ">sock_write()</a>.  <a href="#a9cf709546a8e6963b9b288cb2bc2abaf">More...</a><br /></td></tr>
<tr class="separator:a9cf709546a8e6963b9b288cb2bc2abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c32e3954c811a7e5897eddf5dfc889"><td class="memItemLeft" align="right" valign="top">int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a07c32e3954c811a7e5897eddf5dfc889">sock_enqueue</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s, const BYTE *data, int len)</td></tr>
<tr class="memdesc:a07c32e3954c811a7e5897eddf5dfc889"><td class="mdescLeft">&#160;</td><td class="mdescRight">For UDP, this function is same as <a class="el" href="pctcp_8c.html#a01e3ddce7d7cc17977caf0363d96f078" title="Writes data and returns length written. ">sock_write()</a>.  <a href="#a07c32e3954c811a7e5897eddf5dfc889">More...</a><br /></td></tr>
<tr class="separator:a07c32e3954c811a7e5897eddf5dfc889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e5e3fd469fd19e77585b40ef6aa620"><td class="memItemLeft" align="right" valign="top"><a id="ad8e5e3fd469fd19e77585b40ef6aa620"></a>
<a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ad8e5e3fd469fd19e77585b40ef6aa620">sock_noflush</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s)</td></tr>
<tr class="memdesc:ad8e5e3fd469fd19e77585b40ef6aa620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets non-flush mode on next TCP write. <br /></td></tr>
<tr class="separator:ad8e5e3fd469fd19e77585b40ef6aa620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6fb692bd64ade352b05b1c13dd968a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a3f6fb692bd64ade352b05b1c13dd968a">sock_flush</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s)</td></tr>
<tr class="memdesc:a3f6fb692bd64ade352b05b1c13dd968a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pending TCP data.  <a href="#a3f6fb692bd64ade352b05b1c13dd968a">More...</a><br /></td></tr>
<tr class="separator:a3f6fb692bd64ade352b05b1c13dd968a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de6c1bc4a5d35f35bae2376cfd9e38c"><td class="memItemLeft" align="right" valign="top"><a id="a1de6c1bc4a5d35f35bae2376cfd9e38c"></a>
<a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a1de6c1bc4a5d35f35bae2376cfd9e38c">sock_flushnext</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s)</td></tr>
<tr class="memdesc:a1de6c1bc4a5d35f35bae2376cfd9e38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes next transmission to have a flush (PUSH bit set). <br /></td></tr>
<tr class="separator:a1de6c1bc4a5d35f35bae2376cfd9e38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1610f06e057aefd9acc9c9e949c619f"><td class="memItemLeft" align="right" valign="top"><a id="ac1610f06e057aefd9acc9c9e949c619f"></a>
int W32_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ac1610f06e057aefd9acc9c9e949c619f">sock_close</a> (<a class="el" href="unionsock__type.html">sock_type</a> *s)</td></tr>
<tr class="memdesc:ac1610f06e057aefd9acc9c9e949c619f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a UDP/TCP socket. <br /></td></tr>
<tr class="separator:ac1610f06e057aefd9acc9c9e949c619f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681efc33e1b3caaae3a29c5610640d7"><td class="memItemLeft" align="right" valign="top"><a id="a9681efc33e1b3caaae3a29c5610640d7"></a>
<a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_rtt_add</b> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, UINT rto, UINT MTU)</td></tr>
<tr class="separator:a9681efc33e1b3caaae3a29c5610640d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1180c6a2343a630e9017abb999bf60"><td class="memItemLeft" align="right" valign="top"><a id="aac1180c6a2343a630e9017abb999bf60"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_rtt_get</b> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s, UINT *rto, UINT *MTU)</td></tr>
<tr class="separator:aac1180c6a2343a630e9017abb999bf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208686293a7ddc2257c25d64134b2e74"><td class="memItemLeft" align="right" valign="top"><a id="a208686293a7ddc2257c25d64134b2e74"></a>
<a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_rtt_clr</b> (const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *s)</td></tr>
<tr class="separator:a208686293a7ddc2257c25d64134b2e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aab6e2261e2d41361b3e335601e8ba2c9"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#aab6e2261e2d41361b3e335601e8ba2c9">hostname</a> [MAX_HOSTLEN+1] = &quot;random-pc&quot;</td></tr>
<tr class="memdesc:aab6e2261e2d41361b3e335601e8ba2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our configured hostname.  <a href="#aab6e2261e2d41361b3e335601e8ba2c9">More...</a><br /></td></tr>
<tr class="separator:aab6e2261e2d41361b3e335601e8ba2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c6def494400a9c8f7a69be34e6a95b"><td class="memItemLeft" align="right" valign="top"><a id="ab3c6def494400a9c8f7a69be34e6a95b"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>_mss</b> = ETH_MAX_DATA - TCP_OVERHEAD</td></tr>
<tr class="separator:ab3c6def494400a9c8f7a69be34e6a95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab823610da8bd87b2d1d136008de75c32"><td class="memItemLeft" align="right" valign="top"><a id="ab823610da8bd87b2d1d136008de75c32"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>_mtu</b> = ETH_MAX_DATA</td></tr>
<tr class="separator:ab823610da8bd87b2d1d136008de75c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f8b2951229ede7122c65f90263700c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a78f8b2951229ede7122c65f90263700c">mtu_discover</a> = 0</td></tr>
<tr class="separator:a78f8b2951229ede7122c65f90263700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ed0e41d4d4b80b96255af52da96eb3"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a44ed0e41d4d4b80b96255af52da96eb3">mtu_blackhole</a> = 0</td></tr>
<tr class="separator:a44ed0e41d4d4b80b96255af52da96eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf27e07658fe8ae54d0eb366b912d2aa"><td class="memItemLeft" align="right" valign="top"><a id="adf27e07658fe8ae54d0eb366b912d2aa"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#adf27e07658fe8ae54d0eb366b912d2aa">block_tcp</a> = 0</td></tr>
<tr class="memdesc:adf27e07658fe8ae54d0eb366b912d2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">when application handles TCP itself <br /></td></tr>
<tr class="separator:adf27e07658fe8ae54d0eb366b912d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e4155ebaa7e0f9bf130a25df15ff46"><td class="memItemLeft" align="right" valign="top"><a id="a32e4155ebaa7e0f9bf130a25df15ff46"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a32e4155ebaa7e0f9bf130a25df15ff46">block_udp</a> = 0</td></tr>
<tr class="memdesc:a32e4155ebaa7e0f9bf130a25df15ff46"><td class="mdescLeft">&#160;</td><td class="mdescRight">when application handles UDP itself <br /></td></tr>
<tr class="separator:a32e4155ebaa7e0f9bf130a25df15ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e07ad6c093546520c2799f0bb86a7d1"><td class="memItemLeft" align="right" valign="top"><a id="a5e07ad6c093546520c2799f0bb86a7d1"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a5e07ad6c093546520c2799f0bb86a7d1">block_icmp</a> = 0</td></tr>
<tr class="memdesc:a5e07ad6c093546520c2799f0bb86a7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">when application handles ICMP itself <br /></td></tr>
<tr class="separator:a5e07ad6c093546520c2799f0bb86a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055898487b61cad4cb50c1c052005293"><td class="memItemLeft" align="right" valign="top"><a id="a055898487b61cad4cb50c1c052005293"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a055898487b61cad4cb50c1c052005293">block_ip</a> = 0</td></tr>
<tr class="memdesc:a055898487b61cad4cb50c1c052005293"><td class="mdescLeft">&#160;</td><td class="mdescRight">when application handles IP itself <br /></td></tr>
<tr class="separator:a055898487b61cad4cb50c1c052005293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9183d8f91d90c0269d64ee4a1581d8c3"><td class="memItemLeft" align="right" valign="top"><a id="a9183d8f91d90c0269d64ee4a1581d8c3"></a>
DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a9183d8f91d90c0269d64ee4a1581d8c3">my_ip_addr</a> = 0L</td></tr>
<tr class="memdesc:a9183d8f91d90c0269d64ee4a1581d8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">our IP address <br /></td></tr>
<tr class="separator:a9183d8f91d90c0269d64ee4a1581d8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b064429453fa5bc15f75a75f746167"><td class="memItemLeft" align="right" valign="top"><a id="ab5b064429453fa5bc15f75a75f746167"></a>
DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ab5b064429453fa5bc15f75a75f746167">sin_mask</a> = 0xFFFFFF00L</td></tr>
<tr class="memdesc:ab5b064429453fa5bc15f75a75f746167"><td class="mdescLeft">&#160;</td><td class="mdescRight">our net-mask, 255.255.255.0 <br /></td></tr>
<tr class="separator:ab5b064429453fa5bc15f75a75f746167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1e020c116e2a536a5acb1d3eddbbe4"><td class="memItemLeft" align="right" valign="top"><a id="a9c1e020c116e2a536a5acb1d3eddbbe4"></a>
_udp_Socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#a9c1e020c116e2a536a5acb1d3eddbbe4">_udp_allsocs</a> = NULL</td></tr>
<tr class="memdesc:a9c1e020c116e2a536a5acb1d3eddbbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of udp-sockets <br /></td></tr>
<tr class="separator:a9c1e020c116e2a536a5acb1d3eddbbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae222828217119b5028f1e6ff74839c5e"><td class="memItemLeft" align="right" valign="top"><a id="ae222828217119b5028f1e6ff74839c5e"></a>
static BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ae222828217119b5028f1e6ff74839c5e">sign_opt</a></td></tr>
<tr class="memdesc:ae222828217119b5028f1e6ff74839c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to insert MD5 option. <br /></td></tr>
<tr class="separator:ae222828217119b5028f1e6ff74839c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b197ebd44e42774ae0ba77b0966b17"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structtcp__rtt.html">tcp_rtt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pctcp_8c.html#ad5b197ebd44e42774ae0ba77b0966b17">rtt_cache</a> [RTTCACHE]</td></tr>
<tr class="memdesc:ad5b197ebd44e42774ae0ba77b0966b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-trip timing cache routines.  <a href="#ad5b197ebd44e42774ae0ba77b0966b17">More...</a><br /></td></tr>
<tr class="separator:ad5b197ebd44e42774ae0ba77b0966b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main TCP handler.</p>
<p>PCTCP, the true worker of Waterloo TCP.</p><ul>
<li>contains all opens, closes, major read/write routines and basic IP handler for incomming packets</li>
<li>Note: much of the TCP/UDP/IP layering is done at the data structure level, not in separate routines or tasks </li>
</ul>

<p class="definition">Definition in file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a334512160f11a831f74c06c390b97284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334512160f11a831f74c06c390b97284">&#9670;&nbsp;</a></span>_tcp_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> _tcp_cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structin___header.html">in_Header</a> *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icmp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icmp_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a TCP socket. </p>
<p>Called upon receiving ICMP errors: host/port UNREACH, REDIRECT, SOURCEQUENCH, TIMXCEED or PARAMPROB. See <a class="el" href="pcicmp_8c.html#a749d213c318cd0afd34afc34e8e5d3d1" title="Handle ICMP_REDIRECT messages. ">icmp_redirect()</a> or <a class="el" href="pcicmp_8c.html#a83f211ebe1d063bb2a7dcfc7bf03c07a" title="Handler for incoming ICMP packets. ">icmp_handler()</a>.</p>
<p>Note: 'ip' is a small copy of the IP-packet originating the ICMP message. We may <em>not</em> have received a copy of the original TCP-header. But we probably won't do any harm if got less TCP-header data than needed. I.e. src_port/dst_port will be zero. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01748">1748</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ac2d6937123b2ce65acec05cc9fea7954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d6937123b2ce65acec05cc9fea7954">&#9670;&nbsp;</a></span>_tcp_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> _tcp_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a TCP connection. </p>
<p>Send a FIN on a particular port &ndash; only works if it is open. Must still allow receives. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00459">459</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

<p class="reference">References <a class="el" href="wattcp_8h_source.html#l00632">tcp_Socket::flags</a>, <a class="el" href="wattcp_8h_source.html#l00649">tcp_Socket::rtt_time</a>, <a class="el" href="timer_8c_source.html#l00500">set_timeout()</a>, <a class="el" href="wattcp_8h_source.html#l00620">tcp_Socket::state</a>, <a class="el" href="wattcp_8h_source.html#l00629">tcp_Socket::timeout</a>, <a class="el" href="wattcp_8h_source.html#l00678">tcp_Socket::tx_datalen</a>, and <a class="el" href="wattcp_8h_source.html#l00630">tcp_Socket::unhappy</a>.</p>

</div>
</div>
<a id="a44799073c1591d7991ebf101cd5d46d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44799073c1591d7991ebf101cd5d46d0">&#9670;&nbsp;</a></span>_tcp_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtcp___socket.html">_tcp_Socket</a>* _tcp_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structin___header.html">in_Header</a> *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>broadcast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main TCP input handler. </p>
<p>All TCP input processing is done from here. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00649">649</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a9dc3b1d4c9d1a83cf1cfeb32d4402479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc3b1d4c9d1a83cf1cfeb32d4402479">&#9670;&nbsp;</a></span>_tcp_keepalive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _tcp_keepalive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>tcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP keepalive transmission. </p>
<p>If connection is idle (tx_datalen == 0), force the peer to send us a segment by sending a keep-alive packet: </p><pre class="fragment">*    &lt;SEQ=SND.UNA-1&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
*  </pre> 
<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02715">2715</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="aab214bb9c379b511b3406e9cd3e0e721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab214bb9c379b511b3406e9cd3e0e721">&#9670;&nbsp;</a></span>_tcp_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _tcp_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and send an outgoing TCP segment. </p>
<p>Several packets may be sent depending on peer's window. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02352">2352</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a078bce2afb070658e8bd83346e75a097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078bce2afb070658e8bd83346e75a097">&#9670;&nbsp;</a></span>_tcp_send_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _tcp_send_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structin___header.html">in_Header</a> *&#160;</td>
          <td class="paramname"><em>his_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtcp___header.html">tcp_Header</a> *&#160;</td>
          <td class="paramname"><em>org_tcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and send a reset (RST) tcp packet. </p>
<dl class="section note"><dt>Note</dt><dd>We modify the orignal segment (orig_tcp) to use it for sending. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02568">2568</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="aafaf3d256d88a1c954dfeadaeac88fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaf3d256d88a1c954dfeadaeac88fa0">&#9670;&nbsp;</a></span>_tcp_sendsoon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _tcp_sendsoon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a transmission pretty soon. </p>
<p>This one has an imperfection at midnight, but it is not significant to the connection performance.</p>
<dl class="section note"><dt>Note</dt><dd>gv: Added - 5 May 2000: Relax retransmission period to <b>tcp_CLOSE_TO</b> when <b>CLOSEWT</b> state is entered.<br />
 Relax retransmission period to <b>tcp_OPEN_TO</b> in <b>SYNSENT</b> state. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00559">559</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ac8b3d5890e3d9d2428199de059f913a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b3d5890e3d9d2428199de059f913a0">&#9670;&nbsp;</a></span>_tcp_unthread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtcp___socket.html">_tcp_Socket</a>* _tcp_unthread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>free_tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unthread a socket from the tcp socket list, if it's there. </p>
<p>Free Tx-buffer if set in <a class="el" href="tcp__fsm_8c.html#aa8d6b688b0b1fac44425595898349953" title="Allocate a Tx-buffer based on peer&#39;s advertised window. ">tcp_set_window()</a>. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00600">600</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="aaad09b4f7b662a0ebecfb634f454598a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad09b4f7b662a0ebecfb634f454598a">&#9670;&nbsp;</a></span>_udp_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> _udp_cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structin___header.html">in_Header</a> *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icmp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icmp_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel an UDP socket. </p>
<p>Called upon receiving ICMP errors: REDIRECT, TIMXCEED, PARAMPROB, or host/port UNREACH. See <a class="el" href="pcicmp_8c.html#a749d213c318cd0afd34afc34e8e5d3d1" title="Handle ICMP_REDIRECT messages. ">icmp_redirect()</a> or <a class="el" href="pcicmp_8c.html#a83f211ebe1d063bb2a7dcfc7bf03c07a" title="Handler for incoming ICMP packets. ">icmp_handler()</a>. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01640">1640</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a9f0004943f4f1ada391f7e2df76b13dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0004943f4f1ada391f7e2df76b13dd">&#9670;&nbsp;</a></span>raw_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int raw_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__raw___socket.html">_raw_Socket</a> *&#160;</td>
          <td class="paramname"><em>raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from a raw-socket. </p>
<p>Don't copy IP-header to buf. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02866">2866</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

<p class="reference">References <a class="el" href="wattcp_8h_source.html#l00694">_raw_Socket::used</a>.</p>

</div>
</div>
<a id="a07c32e3954c811a7e5897eddf5dfc889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c32e3954c811a7e5897eddf5dfc889">&#9670;&nbsp;</a></span>sock_enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL sock_enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For UDP, this function is same as <a class="el" href="pctcp_8c.html#a01e3ddce7d7cc17977caf0363d96f078" title="Writes data and returns length written. ">sock_write()</a>. </p>
<p>For TCP, this function enqueues 'data' to transmit queue.</p>
<dl class="section note"><dt>Note</dt><dd>user <b>must</b> not touch 'data' while sock_tbused() returns &gt; 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l03061">3061</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ad5a17eaa8046675c3530efed90bbe916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a17eaa8046675c3530efed90bbe916">&#9670;&nbsp;</a></span>sock_fastread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL sock_fastread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a socket with maximum 'len' bytes. </p>
<dl class="section note"><dt>Note</dt><dd>does <b>not</b> busywait until buffer is full. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02948">2948</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

<p class="reference">References <a class="el" href="wattcp_8h_source.html#l00693">_raw_Socket::ip_type</a>, <a class="el" href="pctcp_8c_source.html#l02866">raw_read()</a>, <a class="el" href="pctcp_8c_source.html#l01841">tcp_read()</a>, and <a class="el" href="pctcp_8c_source.html#l01584">udp_read()</a>.</p>

</div>
</div>
<a id="a9cf709546a8e6963b9b288cb2bc2abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf709546a8e6963b9b288cb2bc2abaf">&#9670;&nbsp;</a></span>sock_fastwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL sock_fastwrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simpler, non-blocking (non-looping) version of <a class="el" href="pctcp_8c.html#a01e3ddce7d7cc17977caf0363d96f078" title="Writes data and returns length written. ">sock_write()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>UDP writes may truncate; check the return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l03035">3035</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a3f6fb692bd64ade352b05b1c13dd968a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6fb692bd64ade352b05b1c13dd968a">&#9670;&nbsp;</a></span>sock_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> W32_CALL sock_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send pending TCP data. </p>
<p>If there is Tx-data to be sent, set the PUSH bit. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l03120">3120</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

<p class="reference">References <a class="el" href="wattcp_8h_source.html#l00632">tcp_Socket::flags</a>, <a class="el" href="wattcp_8h_source.html#l00623">tcp_Socket::send_una</a>, and <a class="el" href="wattcp_8h_source.html#l00678">tcp_Socket::tx_datalen</a>.</p>

</div>
</div>
<a id="af4a2c676e1b51d281aafed877db6d0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a2c676e1b51d281aafed877db6d0ae">&#9670;&nbsp;</a></span>sock_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL sock_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a socket with maximum 'maxlen' bytes. </p>
<dl class="section note"><dt>Note</dt><dd>busywaits until 'buf' is full (and call 's-&gt;usr_yield'). </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>socket is not open. </td></tr>
    <tr><td class="paramname">&lt;=maxlen</td><td>socket has data to be read. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02892">2892</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

<p class="reference">References <a class="el" href="pctcp_8c_source.html#l02866">raw_read()</a>, <a class="el" href="pctcp_8c_source.html#l01841">tcp_read()</a>, <a class="el" href="pctcp_8c_source.html#l01402">tcp_tick()</a>, and <a class="el" href="pctcp_8c_source.html#l01584">udp_read()</a>.</p>

</div>
</div>
<a id="a6ab13fbf4fc455cf1d5ecf1d1771b899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab13fbf4fc455cf1d5ecf1d1771b899">&#9670;&nbsp;</a></span>sock_reduce_mss()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> sock_reduce_mss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>MTU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce socket MSS upon receiving ICMP_UNREACH_NEEDFRAG. </p>
<p>'MTU' is next-hop suggested MTU or 0 if router doesn't support RFC-1191. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01611">1611</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

<p class="reference">References <a class="el" href="wattcp_8h_source.html#l00656">tcp_Socket::max_seg</a>.</p>

</div>
</div>
<a id="a01e3ddce7d7cc17977caf0363d96f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e3ddce7d7cc17977caf0363d96f078">&#9670;&nbsp;</a></span>sock_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL sock_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data and returns length written. </p>
<dl class="section note"><dt>Note</dt><dd>sends with PUSH-bit (flush data). </dd>
<dd>
repeatedly calls 's-&gt;usr_yield'. </dd>
<dd>
UDP packetsare sent in chunks of MTU-28. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if some error in lower layer. </td></tr>
    <tr><td class="paramname">'len'</td><td>if all data sent okay. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02977">2977</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a617de6be629621a5e56a7eafcad6c899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617de6be629621a5e56a7eafcad6c899">&#9670;&nbsp;</a></span>sock_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidProc W32_CALL sock_yield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VoidProc&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable user defined yield function. </p>
<p>Return address of previous yield function. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02820">2820</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ab17ad983a90a10796a8601a4c1b90d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17ad983a90a10796a8601a4c1b90d80">&#9670;&nbsp;</a></span>tcp_checksum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOL tcp_checksum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structin___header.html">in_Header</a> *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtcp___header.html">tcp_Header</a> *&#160;</td>
          <td class="paramname"><em>tcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify the TCP header checksum. </p>
<dl class="section note"><dt>Note</dt><dd>Not used for IPv6. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02050">2050</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a61003b3891c22ba24b707d0f02248a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61003b3891c22ba24b707d0f02248a49">&#9670;&nbsp;</a></span>tcp_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL tcp_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>lport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtoHandler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passively opens TCP a connection. </p>
<p>Listen for a connection on a particular port </p>
<p>&lt;</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000092">Todo:</a></b></dt><dd>use <b>mss</b> from setsockopt() </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00393">393</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ab99f8eda55106ab449f7addc3efe5458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99f8eda55106ab449f7addc3efe5458">&#9670;&nbsp;</a></span>tcp_no_arp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> tcp_no_arp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called for a TCP socket when ARP lookup fails. </p>
<p>If socket allocated by BSD API, do a read wakeup on it. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02025">2025</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ad3ab18774baa34ab715362614c1cbb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ab18774baa34ab715362614c1cbb93">&#9670;&nbsp;</a></span>tcp_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL tcp_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>lport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>rport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtoHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actively open a TCP connection. </p>
<p>Make connection to a particular destination. Not used for IPv6 (see <a class="el" href="socket_8c.html#a83afb2e5151041495090582907242c8a">_TCP6_open()</a>). </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on error. 's-&gt;err_msg' filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>'lport' is local port to associate with the connection. </dd>
<dd>
'rport' is remote port for same connection. </dd></dl>
<p>&lt;</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000090">Todo:</a></b></dt><dd>use <b>mss</b> from setsockopt() </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000091">Todo:</a></b></dt><dd>use <b>TCP_NODELAY</b> set in setsockopt() </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00312">312</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a750496d700acf8452af305385a518f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750496d700acf8452af305385a518f53">&#9670;&nbsp;</a></span>tcp_opt_maxsegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline int tcp_opt_maxsegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TCP option routines. </p>
<dl class="section note"><dt>Note</dt><dd>Each of these <b>MUST</b> add multiple of 4 bytes of options. Insert MSS option. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02192">2192</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ae5b89a064fdf4cc61dbc20ec5feb4a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b89a064fdf4cc61dbc20ec5feb4a06">&#9670;&nbsp;</a></span>tcp_opt_timestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline int tcp_opt_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>ts_echo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert TimeStamp option. </p>
<p>nmap uses TSval (ts_now) as indication of uptime, so send </p><h1>of msec since started.</h1>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02205">2205</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a145bcb229d5f15a3a6d08ce5fbb1f93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145bcb229d5f15a3a6d08ce5fbb1f93e">&#9670;&nbsp;</a></span>tcp_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int tcp_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a TCP socket. </p>
<ul>
<li><b>buf</b> where to put data. <dl class="section note"><dt>Note</dt><dd>does large buffering. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01841">1841</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a21f43244bafa5dc4a49f390fc9d0e96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f43244bafa5dc4a49f390fc9d0e96e">&#9670;&nbsp;</a></span>tcp_Retransmitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> tcp_Retransmitter </td>
          <td>(</td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>force</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called periodically to perform retransmissions. </p>
<ul>
<li>if 'force == 1' do it now. </li>
</ul>
<p>&lt; dup ACK counter ?</p>
<p>&lt;</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000094">Todo:</a></b></dt><dd>set "Slow-start" threshold </dd></dl>
<p>&lt;</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000095">Todo:</a></b></dt><dd>Allow for 3 SYN before giving up </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01222">1222</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a553f9220c56e51890f7501d389e11a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553f9220c56e51890f7501d389e11a99">&#9670;&nbsp;</a></span>tcp_rtt_win()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tcp_8h.html#ac1f7eba6bc7e9c6de5782062335462e6">void</a> tcp_rtt_win </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update retransmission timer, VJ algorithm and TCP windows. </p>
<p>Only called after we received something on socket. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000097">Todo:</a></b></dt><dd>Use the threshold to signify "end-of-Slow-Start" (equilibrium) </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l02076">2076</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a5db19271d908ae67bcfebf2499c6a666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db19271d908ae67bcfebf2499c6a666">&#9670;&nbsp;</a></span>tcp_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD W32_CALL tcp_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsock__type.html">sock_type</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Must</b> be called periodically by user application (or BSD socket API). </p>
<ul>
<li>if 's != NULL', check this socket for timeout. </li>
<li>if 's == NULL', check all sockets in list.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if 's' is non-NULL and 's' closes. </td></tr>
    <tr><td class="paramname">!0</td><td>if 's' is NULL or 's' is still open. </td></tr>
  </table>
  </dd>
</dl>
<p>Don't enter this loop if reentered. That could return the same packet twice (before we call <a class="el" href="pcsed_8c.html#afe5dcd5a9a1a3dec831f0883d475096a" title="Free an input buffer once it is no longer needed. ">_eth_free()</a> on the 1st packet). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000096">Todo:</a></b></dt><dd>Limit the time spent here (clamp # of loops) </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01402">1402</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

<p class="reference">References <a class="el" href="pctcp_8c_source.html#l00600">_tcp_unthread()</a>, and <a class="el" href="wattcp_8h_source.html#l00620">tcp_Socket::state</a>.</p>

</div>
</div>
<a id="a16f30c2a196fc4212def321259ee308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f30c2a196fc4212def321259ee308c">&#9670;&nbsp;</a></span>tcp_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int tcp_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcp___socket.html">_tcp_Socket</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to a TCP connection. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>Number of bytes written. </td></tr>
    <tr><td class="paramname">0</td><td>Connection is not established. </td></tr>
    <tr><td class="paramname">-1</td><td>Error in lower layer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01889">1889</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="aba36f21d6b0c713d872f9b5820367cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba36f21d6b0c713d872f9b5820367cf4">&#9670;&nbsp;</a></span>udp_demux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static _udp_Socket* udp_demux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structin___header.html">in_Header</a> *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>ip_bcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>destin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>srcPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>dstPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>udp_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Demultiplexer for incoming UDP packets. </p>
<p>Don't debug packet if no match was found (except if '*udp_err'). </p>
<p>Demux to active sockets. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000093">Todo:</a></b></dt><dd>use some kind of hashing to speed up the search. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00877">877</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ae8e365b2058c8ce00c89befc10176b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e365b2058c8ce00c89befc10176b06">&#9670;&nbsp;</a></span>udp_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int W32_CALL udp_open </td>
          <td>(</td>
          <td class="paramtype">_udp_Socket *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>lport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtoHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UDP active open. </p>
<p>Open a connection on a particular port. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00196">196</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a25b797c7ad66da39463844059ca6ff8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b797c7ad66da39463844059ca6ff8d">&#9670;&nbsp;</a></span>udp_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int udp_read </td>
          <td>(</td>
          <td class="paramtype">_udp_Socket *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from UDP socket. </p>
<ul>
<li><b>buf</b> where data is put. </li>
<li><b>maxlen</b> read max this amount. <dl class="section note"><dt>Note</dt><dd>does large buffering. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01584">1584</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ada7ba67c879b514ea6f19c8ddb7abdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7ba67c879b514ea6f19c8ddb7abdbc">&#9670;&nbsp;</a></span>udp_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int udp_write </td>
          <td>(</td>
          <td class="paramtype">_udp_Socket *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an UDP packet. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes data fits in one datagram, else only the first fragment will be sent! Because MTU is used for splits, the guaranteed max data size is 'MTU - UDP_OVERHEAD = 548' for a non-fragmented datagram. Routers should handle at least 576 bytes datagrams. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l01504">1504</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aab6e2261e2d41361b3e335601e8ba2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6e2261e2d41361b3e335601e8ba2c9">&#9670;&nbsp;</a></span>hostname</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char hostname[MAX_HOSTLEN+1] = &quot;random-pc&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Our configured hostname. </p>
<p>Not the FQDN. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00059">59</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a44ed0e41d4d4b80b96255af52da96eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ed0e41d4d4b80b96255af52da96eb3">&#9670;&nbsp;</a></span>mtu_blackhole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL mtu_blackhole = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000089">Todo:</a></b></dt><dd>Add PMTU blackhole detection </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00064">64</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="a78f8b2951229ede7122c65f90263700c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f8b2951229ede7122c65f90263700c">&#9670;&nbsp;</a></span>mtu_discover</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL mtu_discover = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000088">Todo:</a></b></dt><dd>Add PMTU discovery method </dd></dl>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l00063">63</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
<a id="ad5b197ebd44e42774ae0ba77b0966b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b197ebd44e42774ae0ba77b0966b17">&#9670;&nbsp;</a></span>rtt_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__rtt.html">tcp_rtt</a> rtt_cache[RTTCACHE]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round-trip timing cache routines. </p>
<p>These functions implement a very simple system for keeping track of network performance for future use in new connections. The emphasis here is on speed of update (rather than optimum cache hit ratio) since tcp_rtt_add() is called every time a TCP connection updates its round trip estimate. </p><dl class="section note"><dt>Note</dt><dd>'rto' is either in ticks or milli-sec depending on if PC has an 8254 Time chip.</dd></dl>
<p>These routines are modified versions from <b>KA9Q</b> by <b>Phil</b> Karn. </p>

<p class="definition">Definition at line <a class="el" href="pctcp_8c_source.html#l03190">3190</a> of file <a class="el" href="pctcp_8c_source.html">pctcp.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_ab8596c82667c0aca9997b52c5dbee43.html">fosco</a></li><li class="navelem"><a class="el" href="dir_080421ebeac7d91b01d16c10e3428daa.html">src</a></li><li class="navelem"><a class="el" href="dir_6df265bdd26cb50194bab3fa12ccd5e5.html">SSH2DOS</a></li><li class="navelem"><a class="el" href="dir_b1c9b88edcbbea5952d2cf10cb584ddc.html">watt32</a></li><li class="navelem"><a class="el" href="dir_7ffa6a371f53fb7b9b5c8573af96f924.html">src</a></li><li class="navelem"><a class="el" href="pctcp_8c.html">pctcp.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
